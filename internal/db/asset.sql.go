// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: asset.sql

package db

import (
	"context"
)

const CreateAsset = `-- name: CreateAsset :one
INSERT INTO assets (ticker, asset_name)
VALUES ($1, $2)
RETURNING id
`

type CreateAssetParams struct {
	Ticker    string `json:"ticker"`
	AssetName string `json:"asset_name"`
}

func (q *Queries) CreateAsset(ctx context.Context, arg CreateAssetParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, CreateAsset, arg.Ticker, arg.AssetName)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const DeleteAsset = `-- name: DeleteAsset :one
DELETE FROM assets
WHERE ticker = $1
RETURNING id
`

func (q *Queries) DeleteAsset(ctx context.Context, ticker string) (int32, error) {
	row := q.db.QueryRowContext(ctx, DeleteAsset, ticker)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const GetAllAssets = `-- name: GetAllAssets :many
SELECT id, ticker, asset_name, is_tradable FROM assets
`

func (q *Queries) GetAllAssets(ctx context.Context) ([]Asset, error) {
	rows, err := q.db.QueryContext(ctx, GetAllAssets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Asset{}
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.Ticker,
			&i.AssetName,
			&i.IsTradable,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAssetByTicker = `-- name: GetAssetByTicker :one
SELECT id, ticker, asset_name, is_tradable FROM assets
WHERE ticker = $1
`

func (q *Queries) GetAssetByTicker(ctx context.Context, ticker string) (Asset, error) {
	row := q.db.QueryRowContext(ctx, GetAssetByTicker, ticker)
	var i Asset
	err := row.Scan(
		&i.ID,
		&i.Ticker,
		&i.AssetName,
		&i.IsTradable,
	)
	return i, err
}

const UpdateAsset = `-- name: UpdateAsset :one
UPDATE assets
SET asset_name = $1, is_tradable = $2
WHERE ticker = $3
RETURNING id
`

type UpdateAssetParams struct {
	AssetName  string `json:"asset_name"`
	IsTradable bool   `json:"is_tradable"`
	Ticker     string `json:"ticker"`
}

func (q *Queries) UpdateAsset(ctx context.Context, arg UpdateAssetParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, UpdateAsset, arg.AssetName, arg.IsTradable, arg.Ticker)
	var id int32
	err := row.Scan(&id)
	return id, err
}
